# 试题

## react事件和普通 html事件有什么区别

- 事件名称
  - 原生： 全小写
  - react: 小驼峰

- 事件函数处理
  - 原生： 字符串
  - react: onClick= {}

- 组织浏览器默认行为
  - 原生： return false
  - react: preventDefault()

VDOM 合成事件 模拟原生DOM的行为，为了跨平台
所有事件存放在数组中

## 受控组件 非受控组件

input select
react 能否知道当前的状态修改

```js

const App = () => {
  const [value,setValue] = useState('');
  const [checked,setChecked] = useState(false);

  return (
    <>
      <input value={value} onInput={event => setValue(event.target.value)}/>

    </>
  )

}

```

## useState中为什么使用数组 而不是对象呢？

```js

  const [count,setCount] = useState(0);

  // 数组解构
  const foo = [1,2,3];
  const [one, two, three] = foo;
  console.log(one,two,three);
  // 对象解构
  const user = {
    id: 123,
    name: 'zz',
  }
  const { id, name } = user;
  console.log(id,name)

  // 数组可以自己命名, 对象不行

```

## React refs

refs允许用户直接访问dom元素

```js
const Test = () => {

  const refs: any = createRef();
  const showResult = () => {
    console.log(refs.current;)
  }

  return (
    <div>
      <input type="text" ref={refs} />
      <button onClick={showResult}></button>
    </div>
  )
}


```

## 为什么使用hooks

1. 复杂组件
  1. componentDidMount componentDidUpdate componentDidWillUnmount
    1. addEventListener removeEventListener
    2. useEffect(()=>()=>{},[])

2. class
  1. this 减少使用


## 错误边界 Error Boundary

UI组件可以捕获发生在子组件的js报错，并能降级处理

static getDerivedStateFromError  componentDidCatch

## 代码分割

webpack rollup

1. import 
2. React.lazy

```js
const Other = React.lazy(()=>import('./math'));

const TestComponent =  () => {
  return (
    <Suspense>
      <Other>
    </Suspense>
  )
}

```

## Fragments

## HOC

high order component

如参是组件 出参是组件的函数。

纯函数

1. 功能模块抽象， 提升复用性
2. 控制渲染流程，权限控制
3. 处理生命周期，检测组件渲染性能的好坏

### 属性代理
1. props

```js

function (comp) {

  const newProps = {
    type: 'HOC'
  }

  return props => <comp {...props} {...newProps}/>;
}

```

2. 抽象state

```js
  const HOC = (comp) => {
    return (props) => {
      const [ name,setName ] = useState();

      const onChange = (e) => {
        setName(e.target.value);
      };

      const newProps = {
        name: {
          value: name,
          onChange:onChange
        }
      }

      return <comp {...props} {...newProps} />

    }
  }

  //props.name.value, props.name.onChange 可以模拟操作state

```

3. 控制渲染逻辑

```js
const HOC = (comp) => {
  return (props)=> {
    if (props.name === 'zz') {
      return comp
    }else {
      return <div>2<div>
    }
  }
}

```

###  反向继承

```js
function HOC(comp){
  return class extends React.Component {
    render(){
      const newProps = {
        type: 'HOC'
      }
      return <comp {...this.props} {...newProps} />
    }
  }
}

function HOC2(comp){

  const didMount = comp.prototype.componentDidMount;

  return class extends comp {

    async componentDidMount(){
      if (didMount) {
        await didMount.apply(this);
      }
      // fetch API
    }

    render(){
      return super.render()
    }
  }
}


```

直接修改返回的React内容

```js
function (comp) {
  return class extends comp {
    render(){
      const tree = super.render();
      const newProps = {};
      if (tree && tree.type === 'input') {
        newProps.value = 'zz';
      }

      const props = {
        ...tree.props,
        ...newProps
      }

      const newTree = React.cloneElement(tree, props, this.props.children);

      return newTree;

    }
  }
}
```

```js
function withFetchHOC(comp, fetchMethods, defaultProps) {
  return class extends React.Component {
    state = {
      data :[]
    }

    async componentDidMount {
      const data = fetchMethods();

      this.setState({ data: data });
    }

    render(){
      return <comp {this.state.data} {...defaultProps} />
    }


  }
}

...

import React from "react"
import MovieList from "./components/MovieList";

class PageA extends React.Component {
  state = {
    movieList:[]
  }
  async componentDidMount {
    const data = fetchMovieList('comedy');

    this.setState({ movieList: data });
  }

  render(){
    return <MovieList {this.state.movieList} emptyTips= "empty comedy"/>
  }
}

```

```js
  export default withFetchHOC(MovieList, fetfetchMovieList('comedy'), { emptyTips:"empty comedy" })

  export default withFetchHOC(MovieList, fetfetchMovieList('action'), { emptyTips:"empty action" })

  const featchMovieType = (type) => {
    return withFetchHOC(MovieList,fetfetchMovieList(type), emptyTips: `empty ${type}` )
  }

```